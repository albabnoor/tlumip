/* Generated by Together */

package com.pb.despair.pi;

import com.pb.despair.model.AbstractCommodity;
import com.pb.despair.model.ConsumptionFunction;
import com.pb.despair.model.ProductionFunction;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class ExponentialQuantities implements ConsumptionFunction, ProductionFunction {

    /**
     * @link aggregation
     *      @associates <{%Dst%}>
     */
    private ArrayList myCommodities = new ArrayList();
    private ArrayList sortedQuantitiesToUse = null;

    public ExponentialQuantities() {

    }
    /**
     * this function returns the overall utility of producing or consuming given the ZUtilities of individual commodities.
     */
    public double overallUtility(double[] individualCommodityUtilities) {
        synchronized (this) {
            // needs to be implemented so that the changes in overall utility are consistent with the changes in consumption
            double[] amount = calcAmounts(individualCommodityUtilities);
            double utility = 0;
            for (int c = 0; c < amount.length; c++) {
                Quantity q = (Quantity) sortedQuantitiesToUse.get(c);
                if (q != null) {
                    utility += individualCommodityUtilities[c] * q.impactOnOverallUtility * amount[c];
                }
            }
            if (Double.isNaN(utility)) {
                utility = 0;
                System.out.println("building up a commodity utility to NaN = error, details follow:");
                for (int c = 0; c < amount.length; c++) {
                    Quantity q = (Quantity) sortedQuantitiesToUse.get(c);
                    if (q != null) {
                        double bob = individualCommodityUtilities[c] *
                                ((Quantity) sortedQuantitiesToUse.get(c)).impactOnOverallUtility * amount[c];
                        System.out.println(q + " has quantity " + amount[c] + " and indiv utility " +
                                individualCommodityUtilities[c] + " and contributes to overall utility by " + bob);
                        utility += bob;
                    } else {
                        System.out.println("entry " + c + " is null -- no effect");
                    }
                    System.out.println("overall utility is therefore: " + utility);
                }
                throw new InvalidZUtilityError(this.toString());
            }
            return utility;
        }
    }


    public double[] overallUtilityDerivatives(double[] individualCommodityUtilities) {
        synchronized (this) {
            // needs to be implemented so that the changes in overall utility are consistent with the changes in consumption
            double[] amount = calcAmounts(individualCommodityUtilities);
            double derivatives[] = new double[amount.length];
//            double utility = 0;
            for (int c = 0; c < amount.length; c++) {
                Quantity q = (Quantity) sortedQuantitiesToUse.get(c);
                if (q != null) {
                    derivatives[c] = q.impactOnOverallUtility * (amount[c] + individualCommodityUtilities[c] * (amount[c] - q.minimum) * q.insideExpMultiplier);
                }
            }
            return derivatives;
        }
    }

    /**
     * This function calculates the amount of each commodity given the utility of each commodity.
     *
     * @param individualCommodityUtilities the utility of buying or selling each of the individual commodities that make up
     *                                     the list of commodities.   Length must match the length of the internal commodity list
     * @return an array specifying the amount of each commodity
     */
    public double[] calcAmounts(double[] individualCommodityUtilities) {
        double[] amounts = new double[sortedQuantitiesToUse.size()];
        if (individualCommodityUtilities.length != amounts.length) {
            throw new Error("Incorrect number of commodities for production/consumption function calculation");
        }
        Quantity q = null;
        for (int c = 0; c < amounts.length; c++) {
            q = (Quantity) sortedQuantitiesToUse.get(c);
            if (q == null) {
                amounts[c] = 0;
            } else {
                if (q.outsideExpMultiplier == 0) {
                    amounts[c] = q.minimum;
                } else {
                    amounts[c] = q.minimum + q.outsideExpMultiplier *
                            Math.exp(q.insideExpMultiplier * (individualCommodityUtilities[c] - q.utilityOffset));
                }
                if (Double.isNaN(amounts[c]) || Double.isInfinite(amounts[c])) {
                    System.out.println("Error in consumption/production function: " + q + " at utility " + individualCommodityUtilities[c] + " is " + amounts[c]);
                }
            }
        }
        return amounts;
    }

    public double[] amountsDerivatives(double[] individualCommodityUtilities) {
        double[] derivatives = new double[sortedQuantitiesToUse.size()];
        if (individualCommodityUtilities.length != derivatives.length) {
            throw new Error("Incorrect number of commodities for production/consumption function calculation");
        }
        Quantity q = null;
        for (int c = 0; c < derivatives.length; c++) {
            q = (Quantity) sortedQuantitiesToUse.get(c);
            if (q == null) {
                derivatives[c] = 0;
            } else {
                if (q.outsideExpMultiplier == 0) {
                    derivatives[c] = 0;
                } else {
                    derivatives[c] = q.outsideExpMultiplier * q.insideExpMultiplier *
                            Math.exp(q.insideExpMultiplier * (individualCommodityUtilities[c] - q.utilityOffset));
                }
            }
        }
        return derivatives;
    }

    public void sortToMatch(Collection commodityList) {
        sortedQuantitiesToUse = new ArrayList();
        Iterator commodityIterator = commodityList.iterator();
        Iterator quantityIterator = null;
        while (commodityIterator.hasNext()) {
            Commodity c = (Commodity) commodityIterator.next();
            quantityIterator = myCommodities.iterator();
            boolean found = false;
            while (quantityIterator.hasNext() && !found) {
                Quantity q = (Quantity) quantityIterator.next();
                if (q.com.equals(c)) {
                    sortedQuantitiesToUse.add(q);
                    found = true;
                }
            }
            if (!found) {
                //                    sortedQuantitiesToUse.add(new Quantity(c, 0, 0, 0, 0, 0));
                sortedQuantitiesToUse.add(null);
            }
        }
    }

    public int size() {
        return sortedQuantitiesToUse.size();
    }



    public void addCommodity(Quantity q) {
        myCommodities.add(q);
    }

    public AbstractCommodity commodityAt(int i) {
        Quantity q = (Quantity) sortedQuantitiesToUse.get(i);
        if (q == null) return null;
        return q.com;
    }

    public static class Quantity {
        public String toString() {
            return (com.toString() + " " + minimum + "+" + outsideExpMultiplier + "exp(" + insideExpMultiplier + "*(u-" +
                    utilityOffset + ")), uimpact :" + impactOnOverallUtility);
        }

        public Commodity com;
        public double minimum = 0.0;
        public double outsideExpMultiplier = 0.0; // aka alpha
        public double insideExpMultiplier = 1.0; // aka lambda
        public double utilityOffset = 0.0;
        public double impactOnOverallUtility = 0.0;

        public Quantity(Commodity com, double minimum, double outsideExpMultiplier, double insideExpMultiplier,
                        double utilityOffset, double impactOnOverallUtility) {
            this.com = com;
            this.minimum = minimum;
            this.outsideExpMultiplier = outsideExpMultiplier;
            this.insideExpMultiplier = insideExpMultiplier;
            this.utilityOffset = utilityOffset;
            this.impactOnOverallUtility = impactOnOverallUtility;
        }
    }



}
