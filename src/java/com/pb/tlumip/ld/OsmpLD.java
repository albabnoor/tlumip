/* Generated by Together */

package com.pb.osmp.ld;

import com.pb.common.sql.JDBCConnection;
import com.pb.common.util.ResourceUtil;

import java.sql.Connection;
import java.sql.DriverManager;
import java.util.*;

import com.pb.models.pecas.AbstractTAZ;
import com.pb.models.pecas.DevelopmentTypeInterface;

import com.pb.common.datastore.DataManager;
import com.pb.common.datafile.JDBCTableReader;
import com.pb.common.datafile.JDBCTableWriter;
import com.pb.common.datafile.TableDataSet;
import com.pb.common.datafile.TableDataSetCollection;

public class OsmpLD {
    static ResourceBundle rbld = null;
    static String landDatabaseDriver;
    static String landDatabaseSpecifier;
    static String inputDatabaseDriver;
    static Connection inputConnection;
    static String inputDatabaseSpecifier;
    static String logFilePath;
    static boolean excelInputDatabase; 
    
    String landTableName;
    
    TableDataSetCollection inputDatabase = null;
    TableDataSet zoneNumbers = null;
    SQLLandInventory land;
    
    
    public static void main(String[] args) {
        try {
            rbld = ResourceUtil.getResourceBundle( "ld" );
            landDatabaseDriver = ResourceUtil.getProperty(rbld,"LandJDBCDriver");
            Class.forName(landDatabaseDriver).newInstance();
            landDatabaseSpecifier = ResourceUtil.getProperty(rbld,"LandDatabase");
            inputDatabaseDriver = ResourceUtil.getProperty(rbld,"InputJDBCDriver");
            inputDatabaseSpecifier = ResourceUtil.getProperty(rbld,"InputDatabase");
            logFilePath = ResourceUtil.getProperty(rbld,"LogFilePath");
            ZoningScheme.developmentDispersionParameter = Double.valueOf(ResourceUtil.getProperty(rbld,"DevelopmentDispersionParameter")).doubleValue();
            ZoningScheme.developmentAlternativesDispersionParameter = Double.valueOf(ResourceUtil.getProperty(rbld,"DevelopmentAlternativesDispersionParameter")).doubleValue();
            excelInputDatabase = ResourceUtil.getProperty(rbld,"ExcelInputDatabase").equalsIgnoreCase("true");
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Can't set up land database",e);
        }
        try {
            ZoningScheme.currentYear = Integer.valueOf(args[0]).intValue();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Put current year on command line");
        }
        System.out.println("Doing development model for year "+ZoningScheme.currentYear);
        OsmpLD mySacogLD = new OsmpLD();
        mySacogLD.landTableName = ResourceUtil.getProperty(rbld,"LandTableName");
        mySacogLD.setUp();

        // this doesn't need to be here, just checking to make sure we can summarize inventory before doing all the work. 
        //mySacogLD.writeOutInventoryTable();
        
        mySacogLD.simulateDevelopment();
        mySacogLD.writeOutInventoryTable();
        mySacogLD.inputDatabase.close();
    }
    
    public void setUp() {
        JDBCConnection inputPBConnection = new JDBCConnection(inputDatabaseSpecifier, inputDatabaseDriver, "", "");
        JDBCTableReader inputTableReader = new JDBCTableReader(inputPBConnection);
        JDBCTableWriter inputTableWriter = new JDBCTableWriter(inputPBConnection);
        inputTableReader.setMangleTableNamesForExcel(excelInputDatabase);
        inputTableWriter.setMangleTableNamesForExcel(excelInputDatabase);
        
        inputDatabase = new TableDataSetCollection(inputTableReader, inputTableWriter);
        TAZ.setUpZones(inputDatabase.getTableDataSet("PECASZonesI"));
        setUpDevelopmentTypes(inputDatabase.getTableDataSet("DevelopmentTypesI"));

        ZoningScheme.setUpZoningSchemes(inputDatabase.getTableDataSet("ZoningSchemesI"));
        
        try {
            land = new SQLLandInventory(landDatabaseDriver,landDatabaseSpecifier, landTableName);
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Can't read in SQLLandInventory",e);
        }
        land.setColumnNames("PEZ","PECASTYPE","PECASSQFT","ZONINGCODE","YEARBUILT","AREA");
        zoneNumbers = inputDatabase.getTableDataSet("PECASZonesI");
        readInSpacePrices(inputDatabase.getTableDataSet("ExchangeResults"));
    } 
    public void simulateDevelopment() {
        ZoningScheme.openLogFile(logFilePath);
        ZoningScheme currentScheme = null;
        int zoneNumberColumn = zoneNumbers.checkColumnPosition("ZoneNumber"); 
        for (int row = 1; row <= zoneNumbers.getRowCount();row++) {
            long zoneNumber = (long) zoneNumbers.getValueAt(row,zoneNumberColumn);
            long numberOfParcels = land.getParcelCount(zoneNumber);
            for (long parcel=1;parcel<=numberOfParcels;parcel++) {
               currentScheme = ZoningScheme.getZoningSchemeByIndex(land.getZoning(zoneNumber,parcel));
               if (currentScheme == null) {
                   ZoningScheme.logBadZoning(zoneNumber,parcel);
               } else {
                    currentScheme.doDevelopment(land,zoneNumber,parcel);
               }
            }
            System.out.println("Finished development in Zone "+zoneNumber);
            ZoningScheme.flushDevelopmentLog();
        }
        ZoningScheme.closeLogFile();
        
    }
    public void writeOutInventoryTable() {
        TableDataSet landInventoryTable = land.summarizeInventory("CommodityNames","Commodity");
        inputDatabase.addTableDataSet(landInventoryTable);
        inputDatabase.flush();
    }

    public void readInSpacePrices(TableDataSet tab) {
        for(int r=1;r<=tab.getRowCount();r++) {
            String typeName = tab.getStringValueAt(r,"Commodity");
            DevelopmentTypeInterface dt = DevelopmentType.getAlreadyCreatedDevelopmentType(typeName);
            if (dt!= null) {
                int zone = (int)tab.getValueAt(r,"ZoneNumber");
                double price = (double)tab.getValueAt(r,"Price");
                AbstractTAZ taz = AbstractTAZ.findZoneByUserNumber(zone);
                if (taz == null) {
                    System.out.println("ERROR: unknown zone number in ExchangeResults "+zone);
                }  else taz.updatePrice(dt,price);
                land.putPrice(zone, dt.getGridCode(), price);
            }
        }
    }

    public static DevelopmentType[] setUpDevelopmentTypes(TableDataSet ctab) {
        ArrayList dtypes = new ArrayList();
        for(int r=1;r<=ctab.getRowCount();r++) {
            String typeName = (ctab.getStringValueAt(r, "DevelopmentTypeName"));
            boolean dynamic = (Boolean.valueOf(ctab.getStringValueAt(r,"DynamicPricesDevelopmentType"))).booleanValue();
            int gridCode = ctab.getStringValueAt(r,"GridCode").charAt(0);
            DevelopmentTypeInterface newDevelopmentType;
            if (dynamic) {
                newDevelopmentType = new DynamicPricesDevelopmentType(typeName,
                        (double)ctab.getValueAt(r,"PortionVacantMultiplier"),
                        (double)ctab.getValueAt(r,"EquilibriumVacancyRate"),
                        (double)ctab.getValueAt(r,"MinimumBasePrice"),gridCode);
            } else {
                newDevelopmentType = new DevelopmentType(typeName,gridCode);
            }
            newDevelopmentType.setConstructionCost((double)ctab.getValueAt(r,"ConstructionCost"));
            newDevelopmentType.setMaintenanceCost((double)ctab.getValueAt(r,"MaintenanceCost"));
            newDevelopmentType.setAddASC((double)ctab.getValueAt(r,"AddASC"));
            newDevelopmentType.setNewASC((double) ctab.getValueAt(r,"NewASC"));
            newDevelopmentType.setRentDiscount((double) ctab.getValueAt(r,"AgeRentDiscount"));
            dtypes.add(newDevelopmentType);
        }
        DevelopmentType[] d = new DevelopmentType[dtypes.size()];
        return (DevelopmentType[]) dtypes.toArray(d);
    }

    


}

